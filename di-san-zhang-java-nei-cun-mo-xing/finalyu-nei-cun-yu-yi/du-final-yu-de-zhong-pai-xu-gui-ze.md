读final域的重排序规则

读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器的。

reader\(\)方法包含3个操作。

·初次读引用变量obj。

·初次读引用变量obj指向对象的普通域j。

·初次读引用变量obj指向对象的final域i。

现在假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，图3-6-3-1所示是一种可能的执行时序。

图3-6-3-1

![](/assets/import-3-6-3-1.png)





在图3-6-3-1中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该

域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象

final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正

确的读取操作。

读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final

域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经

被A线程初始化过了。

