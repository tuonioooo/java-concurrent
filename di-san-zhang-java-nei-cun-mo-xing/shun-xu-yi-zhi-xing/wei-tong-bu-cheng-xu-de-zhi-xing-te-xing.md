未同步程序的执行特性

对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的

值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证线程读操作读取

到的值不会无中生有（Out Of Thin Air）的冒出来。为了实现最小安全性，JVM在堆上分配对象

时，首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部会同步这两个操作）。因

此，在已清零的内存空间（Pre-zeroed Memory）分配对象时，域的默认初始化已经完成了。

JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为

如果想要保证执行结果一致，JMM需要禁止大量的处理器和编译器的优化，这对程序的执行

性能会产生很大的影响。而且未同步程序在顺序一致性模型中执行时，整体是无序的，其执行

结果往往无法预知。而且，保证未同步程序在这两个模型中的执行结果一致没什么意义。

未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两

个模型中的执行特性有如下几个差异。

1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的

操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前

面已经讲过了，这里就不再赘述。

2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程

能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。

3）JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保

证对所有的内存读/写操作都具有原子性。

第3个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内

存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步

骤称之为总线事务（Bus Transaction）。总线事务包括读事务（Read Transaction）和写事务（Write

Transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会

读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事

务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和I/O设备执行内存的读/写。

下面，让我们通过一个示意图来说明总线的工作机制，如图3-14所示。

