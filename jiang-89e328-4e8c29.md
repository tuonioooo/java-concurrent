# 讲解\(二\)

## **前言**

Map 这样的 Key Value 在软件开发中是非常经典的结构，常用于在内存中存放数据。

## **HashMap**

* ### **Base 1.7**

**1.7 中的数据结构图：**

![](https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl2YrHfgckicQvCZFaT240KJuniawDic6DVLxibmw3cLgbicF8ibyajrpibGcbezT6TWR0ibJcDmnHmwuss7ZQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1)

**先来看看 1.7 中的实现。**

![](https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl2YrHfgckicQvCZFaT240KJuzYhM1hVO4fokTzXoDrcy5zjRLibfXhhF1QrWxXu3S9uVACrAbcLjNvg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1)

**这是 HashMap 中比较核心的几个成员变量；看看分别是什么意思？**

1. 初始化桶大小，因为底层是数组，所以这是数组默认的大小。

2. 桶最大值。

3. 默认的负载因子（0.75）

4. table 真正存放数据的数组。

5. Map 存放数量的大小。

6. 桶大小，可在初始化时显式指定。

7. 负载因子，可在初始化时显式指定。

**重点解释下负载因子：**

由于给定的 HashMap 的容量大小是固定的，比如默认初始化：

```
 public HashMap() {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    }

    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);

        this.loadFactor = loadFactor;
        threshold = initialCapacity;
        init();
    }
```

给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 \* 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。

因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。

**根据代码可以看到其实真正存放数据的是transient Entry&lt;K,V&gt;\[\] table = \(Entry&lt;K,V&gt;\[\]\) EMPTY\_TABLE;**

**这个数组，那么它又是如何定义的呢？**

![](https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl2YrHfgckicQvCZFaT240KJuX0o4uxUqo3XFULiaWedAr9z48BjRicBLaLLq9muCt1ftNafgJDyWKribg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1)

Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出：

* key 就是写入时的键。

* value 自然就是值。

* 开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。

* hash 存放的是当前 key 的 hashcode。

知晓了基本结构，那来看看其中重要的写入、获取函数：

#### **put 方法**

```
 public V put(K key, V value) {
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key);
        int i = indexFor(hash, table.length);
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        addEntry(hash, key, value, i);
        return null;
    }
```

* 判断当前数组是否需要初始化。

* 如果 key 为空，则 put 一个空值进去。

* 根据 key 计算出 hashcode。

* 根据计算出的 hashcode 定位出所在桶。

* 如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。

* 如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。

**addEntry\(hash, key, value, i\);实现**

```
void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size >= threshold) && (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }

    void createEntry(int hash, K key, V value, int bucketIndex) {
        Entry<K,V> e = table[bucketIndex];
        table[bucketIndex] = new Entry<>(hash, key, value, e);
        size++;
    }
```

当调用 addEntry 写入 Entry 时需要判断是否需要扩容。

如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。而在 createEntry 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。

#### **get 方法**

```
public V get(Object key) {
        if (key == null)
            return getForNullKey();
        Entry<K,V> entry = getEntry(key);

        return null == entry ? null : entry.getValue();
    }

    final Entry<K,V> getEntry(Object key) {
        if (size == 0) {
            return null;
        }

        int hash = (key == null) ? 0 : hash(key);
        for (Entry<K,V> e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &&
                ((k = e.key) == key || (key != null && key.equals(k))))
                return e;
        }
        return null;
    }
```

* 首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。

* 判断该位置是否为链表。

* 不是链表就根据 key、key 的 hashcode 是否相等来返回值。

* 为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。

* 啥都没取到就直接返回 null 。



